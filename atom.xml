<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>web personal developer</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.webpersonaldeveloper.cn/"/>
  <updated>2016-06-18T06:10:36.459Z</updated>
  <id>http://www.webpersonaldeveloper.cn/</id>
  
  <author>
    <name>Stone Fang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cassandra 常见问题</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/06/17/docker%20issues/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/06/17/docker issues/</id>
    <published>2016-06-17T08:22:17.046Z</published>
    <updated>2016-06-18T06:10:36.459Z</updated>
    
    <content type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文主要介绍在部署cassandra集群以及使用cassandra过程中遇到的一些问题。&lt;/p&gt;
&lt;p&gt;文章只发布在CSDN 和&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;个人站点&quot;&gt;个人站点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多nosql文章可以访问&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;stone fang 个人主页&quot;&gt;stone fang 个人主页&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;Q1:cassandra 如何将一个节点设置为seed node,seed node与其他node有什么区别&lt;/p&gt;
&lt;p&gt;A1:设置seed node很简单，在cassandra.yaml 中 -seeds 选项中设置。可以设置多个node.&lt;br&gt;seed node 是用于新节点加入到集群中，新节点需要通过seed node去发现集群加载的data信息。一旦新节点bootstrap后&lt;br&gt;seed node 就没有作用了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;seed_provider: 
- class_name: org.apache.cassandra.locator.SimpleSeedProvider
  parameters:
      - seeds: &amp;quot;127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Q2:cassandra node 新加入到集群中，autobootstrap默认为true，所以可以进行bootstrap，但是加入到集群后，然后重启node，并没有设置&lt;br&gt;autobootstrap为false，为什么这时候cassandra不再做bootstrap呢。&lt;/p&gt;
&lt;p&gt;A2:bootstrap意思是一个新节点加入到集群中，这个新节点加入到集群的partition ring中。负责一部分partition key。其他节点也会更新&lt;br&gt;保存的partition 环信息。而当我们重启节点时，节点会首先自动缓存Gossip状态信息，在重新启动时会自动加载。所以在cassandra部署过程中，你会发现&lt;br&gt;有时候你新启动一个节点，并没有指定seed node，这个node也莫名其妙的加入到了cluster。这是gossip状态没有清除，保存了以前的信息。&lt;br&gt;可以在启动时添加-Dcassandra.load_ring_state=false&lt;/p&gt;
&lt;p&gt;Q3:unable to gossip with seeds.seed 设置有效，也没有防火墙屏蔽。为什么无法gossip，启动失败&lt;/p&gt;
&lt;p&gt;A3:这个可能性很多，首先检查下cassandra.yaml 配置文件的listen_address和broadcast_address.在seed node上&lt;br&gt;面ping下broadcast_address。是否能够ping通。通常在云主机平台上，主机有public ip和private ip.broad_address 需要配置为public ip,listen_address&lt;br&gt;可以配置private ip。&lt;/p&gt;
&lt;p&gt;作者还碰到过一个情况：cassandra 运行在docker中，listen_address是docker分配的私有地址172.17.0.2.&lt;br&gt;但是不知道什么时候配置了route表。将172.17.0.0配置到节点的public ip。导致cassandra无法启动。gossip 不到seeds node.&lt;br&gt;172.17.0.0 应该是路由到docker 的网桥，默认是docker0.将配置错的路由删除掉。就可以了。&lt;/p&gt;
&lt;p&gt;Q4:JMX 访问，设置了remote 方式，7199 端口也打开了，但是仍然访问不了。&lt;/p&gt;
&lt;p&gt;A4:cassandra-env.sh 中配置了JMX访问方式，可以传参。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if [ &amp;quot;x$LOCAL_JMX&amp;quot; = &amp;quot;x&amp;quot; ]; then
LOCAL_JMX=yes
fi
JMX_PORT=&amp;quot;7199&amp;quot;

if [ &amp;quot;$LOCAL_JMX&amp;quot; = &amp;quot;yes&amp;quot; ]; then
  JVM_OPTS=&amp;quot;$JVM_OPTS -Dcassandra.jmx.local.port=$JMX_PORT -XX:+DisableExplicitGC&amp;quot;
else
  JVM_OPTS=&amp;quot;$JVM_OPTS -Dcom.sun.management.jmxremote.port=$JMX_PORT&amp;quot;
  JVM_OPTS=&amp;quot;$JVM_OPTS -Dcom.sun.management.jmxremote.rmi.port=$JMX_PORT&amp;quot;
  JVM_OPTS=&amp;quot;$JVM_OPTS -Dcom.sun.management.jmxremote.ssl=false&amp;quot;
  JVM_OPTS=&amp;quot;$JVM_OPTS -Dcom.sun.management.jmxremote.authenticate=true&amp;quot;
  JVM_OPTS=&amp;quot;$JVM_OPTS -Dcom.sun.management.jmxremote.password.file=/etc/cassandra/jmxremote.password&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实验环境中可以自行设定了外部访问方式，&lt;br&gt;将jmxremote.authenticate值设为false.就不需要登录名和密码了。通常是使用jconsle 来测试JMX是否可以&lt;br&gt;通过remote连接。在docker环境下7199已经映射了，但是仍然访问不了。cassandra的listen_address是docker分配的&lt;br&gt;private ip.broadcast_address是public ip.jconsole连接的public ip.这时候无法访问，解决办法是在&lt;br&gt;cassandra-env.sh中设置jmx暴露出的ip，像JMX_PORT=”7199”一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JVM_OPTS=&amp;quot;$JVM_OPTS -Djava.rmi.server.hostname=&amp;lt;public ip&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Q5:新节点加入时状态一直都是UJ,而不是UN&lt;/p&gt;
&lt;p&gt;A5:UJ J表示在加入。已经存在的cluster数据很多，将数据从其他节点中移过来需要时间。可以通过nodetool netstats查看下&lt;br&gt;其他节点传输数据到新节点的情况。如果已经没有stream data了，但是状态还是J。可能是sstable在做compaction工作。&lt;/p&gt;
&lt;p&gt;Q6:如何理解在关系型数据库中是首先设计DB Schema，然后考虑查询。但是在cassandra中，需要首先考虑查询场景，然后再去设计DB Schema&lt;/p&gt;
&lt;p&gt;A6:关系型数据库数据是行列式存储，一系列的行和列组成了表，一张表的每一行的列数是固定的。可以根据任意一列来去查询数据。&lt;br&gt;所以查询场景不需要优先考虑。而在cassandra则不是，首先cassandra是根据partition key分布在各个节点上的。节点上的数据又是根据cluster key来分布的。&lt;br&gt;一种查询模式对应的一张表。&lt;br&gt;eg&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table test (
name text,
age int,
address text,
PRIMARY KEY(name,address,age)      
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里name是partition key，address,age是cluster key.数据在节点上的存储方式是/address/age 这种分层结构。所以查询的时候只能根据address来查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select *from test where address=&amp;apos;xx&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不能根据age,因为age在address的下一层结构中，无法索引到。如果想根据age，必须重新创建一张表。或者使用materialized view.&lt;/p&gt;
&lt;p&gt;综上所述，所以说在cassandra中需要先考虑查询场景，然后再去设计DB Schema.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文主要介绍在部署cassandra集群以及使用cassandra过程中遇到的一些问题。&lt;/p&gt;
&lt;p&gt;文章只发布在CSDN 和&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;个人站点&quot;&gt;个人站点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多nosql文章可以访问&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;stone fang 个人主页&quot;&gt;stone fang 个人主页&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cassandra monitor 方案评估</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/05/31/cassandra%20monitor/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/05/31/cassandra monitor/</id>
    <published>2016-05-31T13:00:20.723Z</published>
    <updated>2016-06-02T09:37:19.559Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;最开始做cassandra monitor 方案的选型时，主要是从cassandra 本身入手，后来发现cassandra运行在JVM上，所有的metrics都是通过JMX 暴露出来。所以又可以使用一些通用的Java Application 的监控方案，作者&lt;br&gt;在调查了很多的实现方案后，最终将范围缩小在graphite,newrelic,opscenter三种解决方案。本文只给出各自的优劣势，具体选用哪种，相信读者自有判断。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;想了解更多cassandra 知识请访问 &lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot;&gt;http://www.webpersonaldeveloper.cn&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;opscenter-VS-graphite-VS-newrelic&quot;&gt;&lt;a href=&quot;#opscenter-VS-graphite-VS-newrelic&quot; class=&quot;headerlink&quot; title=&quot;opscenter VS graphite VS newrelic&quot;&gt;&lt;/a&gt;opscenter VS graphite VS newrelic&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#环境部署&quot;&gt;环境部署&lt;/a&gt;    &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#收集的metrics对比&quot;&gt;收集的metrics对比 &lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#cassandra-metrics&quot;&gt;cassandra metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#os-metrics&quot;&gt;os metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#application-metrics&quot;&gt;application metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#扩展功能&quot;&gt;扩展功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#开发维护成本&quot;&gt;开发维护成本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cassandra 版本限制&quot;&gt;cassandra 版本限制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;环境部署&quot;&gt;&lt;a href=&quot;#环境部署&quot; class=&quot;headerlink&quot; title=&quot;环境部署&quot;&gt;&lt;/a&gt;环境部署&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;opscenter:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从datastax 下载opscenter,install完了以后，就可以在opscenter 的UI 上面安装cassandra cluster,然后在cluster 上面安装opscenter agent.cassandra 和agent可以在opscenter 的UI上面安装，也可以在各个Node上面安装&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;graphite:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要有三部分构成graphite 绘图，Carbon作为缓存，Whisper存储数据。此外通常需要使用grafana 来作为UI显示，因为graphite绘图太丑了，功能也有限。&lt;br&gt;graphite 环境搭建及配置及其复杂，需要安装很多的插件，所以版本适配也很麻烦。不过有了docker以后一切变得简单了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kamon-io/docker-grafana-graphite&quot; title=&quot;github&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/kamon-io/docker-grafana-graphite&lt;/a&gt;&lt;br&gt;(可以fork这个repo然后按照你的需求更改)&lt;/p&gt;
&lt;p&gt;部署好graphite server，还需要在每个cassandra 配置发送&lt;br&gt;新建一个metrics.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;graphite:
period: 30
timeunit: &amp;apos;SECONDS&amp;apos;
prefix: &amp;apos;cassandra-cluster-prefix.node1&amp;apos;
hosts:
 - host: &amp;apos;xxx&amp;apos;
   port: 2003
predicate:
  color: &amp;quot;white&amp;quot;
  useQualifiedName: true
  patterns:
    - &amp;quot;^org.+&amp;quot;
    - &amp;quot;^jvm.+&amp;quot;
    - &amp;quot;^java.lang.+&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在cassandra-env.sh 配置JVM启动项&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JVM_OPTS=&amp;quot;$JVM_OPTS -Dcassandra.metricsReporterConfigFile=metrics.yaml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;newrelic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只用配置下newrelic 的config，然后run plugin&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/threelegs/newrelic-plugins&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/threelegs/newrelic-plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;newrelic cassandra 的plugin很多年没有更新了，所以应该支持Cassandra 2.x版本，不支持Cassandra 3.x的版本。&lt;br&gt;不过自己开发也很简单，只是有些metrics 名字，包名换了，可以自己fork下来进行修改。&lt;/p&gt;
&lt;p&gt;opscenter=newrelic&amp;gt;graphite(即使使用docker，graphite还是部署最复杂的一个)&lt;/p&gt;
&lt;h2 id=&quot;收集的metrics对比&quot;&gt;&lt;a href=&quot;#收集的metrics对比&quot; class=&quot;headerlink&quot; title=&quot;收集的metrics对比&quot;&gt;&lt;/a&gt;收集的metrics对比&lt;/h2&gt;&lt;h3 id=&quot;cassandra-metrics&quot;&gt;&lt;a href=&quot;#cassandra-metrics&quot; class=&quot;headerlink&quot; title=&quot;cassandra metrics&quot;&gt;&lt;/a&gt;cassandra metrics&lt;/h3&gt;&lt;p&gt;cassandra metrics 主要就是JMX 暴露出来的MBean,包括Read/Write request,latency.还有一些是compaction task等信息。我们通过JConsole 工具就能够查看，不过是JConsole 界面过于丑陋，以及无法保存历史数据，绘制图形也不美观等种种缺点导致我们&lt;br&gt;不去使用它。&lt;/p&gt;
&lt;p&gt;opscenter=graphite=newrelic cassandra metrics 三种收集方案都可以收集到，没什么差异。&lt;/p&gt;
&lt;h3 id=&quot;os-metrics&quot;&gt;&lt;a href=&quot;#os-metrics&quot; class=&quot;headerlink&quot; title=&quot;os metrics&quot;&gt;&lt;/a&gt;os metrics&lt;/h3&gt;&lt;p&gt;OS metrics 包括cpu,内存，disk使用情况。&lt;br&gt;opscenter集成在一起，看起来很方便；graphite需要使用第三方插件collectd进行收集；newrelic 同样也可以。&lt;/p&gt;
&lt;p&gt;opscenter=newrelic&amp;gt;graphite&lt;/p&gt;
&lt;h3 id=&quot;application-metrics&quot;&gt;&lt;a href=&quot;#application-metrics&quot; class=&quot;headerlink&quot; title=&quot;application metrics&quot;&gt;&lt;/a&gt;application metrics&lt;/h3&gt;&lt;p&gt;cassandra 是数据库服务，但是作为monitor，通常需要查看整体情况。client请求出现问题了，我们可能不仅需要分析&lt;br&gt;数据库，还需要分析application server.当然希望能够将application server 的信息与cassandra整合到同一页面&lt;br&gt;而不是多个监控平台。opscenter 没法做到，graphite 可以，newrelic 可以&lt;/p&gt;
&lt;p&gt;graphite=newrelic&amp;gt;opscenter&lt;/p&gt;
&lt;h2 id=&quot;扩展功能&quot;&gt;&lt;a href=&quot;#扩展功能&quot; class=&quot;headerlink&quot; title=&quot;扩展功能&quot;&gt;&lt;/a&gt;扩展功能&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;历史数据保存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;opscenter、graphite 都是支持参数配置保存多少天的。&lt;br&gt;newrelic 需要钱才可以保存更多天。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;权限管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;opscenter支持admin对权限进行管理，但是所有的metrics作为一个整体，无法控制让某些用户只看某部分metrics&lt;br&gt;&lt;a href=&quot;https://docs.datastax.com/en/latest-opsc/opsc/configure/opscManageUsers.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.datastax.com/en/latest-opsc/opsc/configure/opscManageUsers.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;graphite 支持organization，不同的organization可以有不同的dashboard.organization中可以添加user，user 角色有四种admin,editor,read only editor,view. 不同的用户在不同的organization中可以有不同的角色。&lt;/p&gt;
&lt;p&gt;newrelic 支持admin,user,restricted user三种，不同的用户可以看到不同的内容。&lt;/p&gt;
&lt;h2 id=&quot;开发维护成本&quot;&gt;&lt;a href=&quot;#开发维护成本&quot; class=&quot;headerlink&quot; title=&quot;开发维护成本&quot;&gt;&lt;/a&gt;开发维护成本&lt;/h2&gt;&lt;p&gt;opscenter 不需要开发，维护如果使用datastax 商业版的cassandra,交license费用即可。其他就是opscenter server的费用&lt;/p&gt;
&lt;p&gt;graphite开源，但是环境部署需要时间和金钱，另外，graphite 有很多的插件构成整个monitor服务，这些插件的维护需要成本。&lt;br&gt;在作者搭建过程就遇到很多的问题。比如多个server的数据聚合问题，读取数据不正确。这些都是需要运营投入到更多的时间的。要是系统&lt;br&gt;不稳定，多投入一个运营，对于公司来说也是一笔不小的投入。&lt;/p&gt;
&lt;p&gt;newrelic 有免费版，但是功能受限，像上面提到的历史数据保存，只能保存一天。收费版就不便宜了。&lt;br&gt;但是newrelic有个独有的好处，是SaaS服务。当需要监控的数据规模增多的时候，不用自己构建监控集群。&lt;br&gt;在这点上，opscenter，graphite 则需要构建cluster 环境&lt;/p&gt;
&lt;p&gt;金钱上&lt;br&gt;graphite&amp;gt;opscenter&amp;gt;newrelic&lt;/p&gt;
&lt;p&gt;人力上 newrelic&amp;gt;opscenter&amp;gt;graphite&lt;/p&gt;
&lt;h2 id=&quot;cassandra-版本限制&quot;&gt;&lt;a href=&quot;#cassandra-版本限制&quot; class=&quot;headerlink&quot; title=&quot;cassandra 版本限制&quot;&gt;&lt;/a&gt;cassandra 版本限制&lt;/h2&gt;&lt;p&gt;opscenter最新版本只支持cassandra opensource 2.1,datastax enterprise 4.8,截止目前，cassandra opensource 已经release 3.7了。&lt;br&gt;所以opscenter 版本比较滞后。&lt;br&gt;graphite 是通用版本，可支持最新版本。&lt;br&gt;newrelic 是plugin形式，需要根据cassandra 更新的metrics来更新plugin 发送的metrics。&lt;/p&gt;
&lt;p&gt;graphite=newrelic&amp;gt;opscenter&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;无论从监控的metrics收集还是监控工具本身的管理来说，三种方案都能提供对应的解决方案。在其他方面略有差异&lt;/p&gt;
&lt;p&gt;1.opscenter 很容易部署，另外集成了对cassandra 的常用操作。无需再登录到cassandra server 上，使用命令行来操作了。他本身不仅仅是个monitor工具，还是个cassandra的操作UI界面。opscenter 有个致命的缺点，cassandra版本受限，如果你想使用最新的cassandra&lt;br&gt;无法实现，这点上觉得是致命的缺陷，是因为一个辅助的监控工具，而影响到主要的数据库功能。&lt;/p&gt;
&lt;p&gt;2.graphite&lt;br&gt;开源是graphite的优势，社区活跃是支撑。有人力能够投入尽管选用此方案。&lt;/p&gt;
&lt;p&gt;3.newrelic 没有什么技术问题需要去解决，花钱解放生产力，如果监控的内容不是产品的核心，也未尝不是一种好方案&lt;/p&gt;
&lt;p&gt;以上仅作者意见，只作参考&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.ailms.me/2014/08/17/note-about-graphite-arch.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ailms.me/2014/08/17/note-about-graphite-arch.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://docs.grafana.org/troubleshooting/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.grafana.org/troubleshooting/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;最开始做cassandra monitor 方案的选型时，主要是从cassandra 本身入手，后来发现cassandra运行在JVM上，所有的metrics都是通过JMX 暴露出来。所以又可以使用一些通用的Java Application 的监控方案，作者&lt;br&gt;在调查了很多的实现方案后，最终将范围缩小在graphite,newrelic,opscenter三种解决方案。本文只给出各自的优劣势，具体选用哪种，相信读者自有判断。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用docker 部署cassandra</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/05/21/cassandra%20in%20docker/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/05/21/cassandra in docker/</id>
    <published>2016-05-21T04:13:00.532Z</published>
    <updated>2016-06-16T05:18:20.791Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文主要介绍在redhat7 平台，利用docker 部署cassandra 集群，除了介绍基本的部署步骤，另外主要&lt;br&gt;讨论类似于cassandra 这种分布式集群系统部署 docker如何进行网络配置的问题&lt;/p&gt;
&lt;p&gt;文章只发布在CSDN与&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;stone Fang个人站点&quot;&gt;http://www.webpersonaldeveloper.cn&lt;/a&gt;,其余站点均属盗版侵权&lt;br&gt;更多cassandra知识请访问 &lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;web 个人开发者&quot;&gt;http://www.webpersonaldeveloper.cn&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;安装docker&quot;&gt;&lt;a href=&quot;#安装docker&quot; class=&quot;headerlink&quot; title=&quot;安装docker&quot;&gt;&lt;/a&gt;安装docker&lt;/h1&gt;&lt;p&gt;最简单的方法，利用已有的脚本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后启动docker 服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service docker start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证是否安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;docker-run-cassandra&quot;&gt;&lt;a href=&quot;#docker-run-cassandra&quot; class=&quot;headerlink&quot; title=&quot;docker run cassandra&quot;&gt;&lt;/a&gt;docker run cassandra&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;docker run --name $CONTAINER_NAME -d -e CASSANDRA-BROADCAST_ADDRESS=xxx.xxx.xxx.xxx

 -e CASSANDRA_DC=XX -e CASSANDRA_RACK=XXX cassandra
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以添加的参数有很多，通常下列这些参数需要指定&lt;/p&gt;
&lt;p&gt;CASSANDRA_LISTEN_ADDRESS:监听进来的连接地址，在docker中默认使用的就是container的ip address&lt;/p&gt;
&lt;p&gt;CASSANDRA_BROADCAST_ADDRESS:广播给别的node的地址。&lt;/p&gt;
&lt;p&gt;CASSANDRA_SEEDS：cassandra bootstrap时通信的节点&lt;/p&gt;
&lt;p&gt;CASSANDRA_DC:multi datacenter 时需要指定datacenter 名&lt;/p&gt;
&lt;p&gt;CASSANDRA_RACK：cassandra机架号&lt;/p&gt;
&lt;p&gt;CASSANDRA_ENDPOITN_SNITCH:网络拓扑策略，用来找寻节点，生产环境一般建议使用GossipingPropertyFileSnitch&lt;/p&gt;
&lt;h1 id=&quot;multi-datacenter-amp-networking&quot;&gt;&lt;a href=&quot;#multi-datacenter-amp-networking&quot; class=&quot;headerlink&quot; title=&quot;multi datacenter &amp;amp; networking&quot;&gt;&lt;/a&gt;multi datacenter &amp;amp; networking&lt;/h1&gt;&lt;h2 id=&quot;Case1-一个node上安装一个cassandra-container&quot;&gt;&lt;a href=&quot;#Case1-一个node上安装一个cassandra-container&quot; class=&quot;headerlink&quot; title=&quot;Case1:一个node上安装一个cassandra container&quot;&gt;&lt;/a&gt;Case1:一个node上安装一个cassandra container&lt;/h2&gt;&lt;p&gt;在6 nodes 上部署两个cassandra datacenter，每个datacenter 3nodes.&lt;br&gt;node1:seed node,没有bootstrap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name $CONTAINER_NAME -d 
-e CASSANDRA_BROADCAST_ADDRESS=XXX -e CASSANDRA_DC=DC1 
-e CASSANDRA_RACK=RAC1 -e CASSANDRA_ENDPOINT_SNITCH=GossipingPropertyFileSnitch 
-p 7000:7000 -p 9042:9042 -p 7199:7199 cassandra
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他node&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name $CONTAINER_NAME -d 
-e CASSANDRA_SEEDS=XXX -e CASSANDRA_BROADCAST_ADDRESS=XXX 
-e CASSANDRA_DC=DC1 -e CASSANDRA_RACK=RAC1 -e CASSANDRA_ENDPOINT_SNITCH=GossipingPropertyFileSnitch 
-p 7000:7000 -p 9042:9042 -p 7199:7199 cassandra
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要将CASSANDRA_BROADCAST_ADDRESS 指定为server 的ip&lt;br&gt;注意这边如果需要使用remote jmx连接到node上，因为docker的存在可能会存在问题。cassandra jmx 暴露出来的不是node的public ip,是docker分配的一个内部地址。&lt;br&gt;所以外部无法访问。可以在cassandra-env.sh 中添加jvm参数，这样外部就可以连接到server了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JVM_OPTS=&amp;quot;$JVM_OPTS -Djava.rmi.server.hostname=&amp;lt;public ip&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Case2-在一个node上安装多个cassandra-container&quot;&gt;&lt;a href=&quot;#Case2-在一个node上安装多个cassandra-container&quot; class=&quot;headerlink&quot; title=&quot;Case2:在一个node上安装多个cassandra container&quot;&gt;&lt;/a&gt;Case2:在一个node上安装多个cassandra container&lt;/h2&gt;&lt;p&gt;这种情况与Case1 有些不同，最重要的是docker网络问题。如何让各个container 有自己独立的ip，并且能够被外部识别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置docker网桥&lt;br&gt;docker 默认的网桥是docker0&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ifconfig docker0 192.168.22.1 netmask 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更新/etc/sysconfig/docker 添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;other_args=&amp;quot;--bip&amp;quot;=192.168.22.1/24&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service docker restart
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;桥接模式下容器之间是可以相互通信的，容器也可以与外部通信&lt;/p&gt;
&lt;p&gt;2.启动cassandra&lt;br&gt;不需要指定Listen Address,和broadcast address,docker 会自动分配，可以在一个server上启动多个cassandra&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name $CONTAINER_NAME -d -e CASSANDRA_DC=DC1 -e CASSANDRA_RACK=RAC1 -e CASSANDRA_ENDPOINT_SNITCH=GossipingPropertyFileSnitch cassandra
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.配置路由&lt;/p&gt;
&lt;p&gt;client 与docker container:cassandra 通信，与其他server 上的cassandra节点通信。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;route add -net 192.168.22.0 netmask 255.255.255.0 gw public_ip
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/_/cassandra/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hub.docker.com/_/cassandra/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/content/advanced_network/bridge.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://yeasy.gitbooks.io/docker_practice/content/advanced_network/bridge.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.infoq.com/cn/articles/docker-network-and-pipework-open-source-explanation-practice&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文主要介绍在redhat7 平台，利用docker 部署cassandra 集群，除了介绍基本的部署步骤，另外主要&lt;br&gt;讨论类似于cassandra 这种分布式集群系统部署 docker如何进行网络配置的问题&lt;/p&gt;
&lt;p&gt;文章只发布在CSDN与&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;stone Fang个人站点&quot;&gt;http://www.webpersonaldeveloper.cn&lt;/a&gt;,其余站点均属盗版侵权&lt;br&gt;更多cassandra知识请访问 &lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot; title=&quot;web 个人开发者&quot;&gt;http://www.webpersonaldeveloper.cn&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redhat7 上安装dummynet</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/05/06/How%20to%20install%20dummynet%20on%20redhat/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/05/06/How to install dummynet on redhat/</id>
    <published>2016-05-06T01:44:41.792Z</published>
    <updated>2016-06-02T12:43:28.895Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;在redhat 上部署dummynet 需要将ipfw 编译为内核模块，而ipfw需要调用linux kernel的一些函数。&lt;br&gt;linux kernel版本在不断提升，相关的数据结构也在变化。所以可能需要根据你要部署的系统内核版本，来调整参数&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;提醒&quot;&gt;&lt;a href=&quot;#提醒&quot; class=&quot;headerlink&quot; title=&quot;提醒&quot;&gt;&lt;/a&gt;提醒&lt;/h1&gt;&lt;p&gt;如果你要部署在Redhat6,CentOS6等内核版本比较低的平台，不必参考下面的部署流程。&lt;br&gt;这篇文章就可以满足的你要求&lt;br&gt;&lt;a href=&quot;http://xmodulo.com/how-to-install-dummynet-on-centos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xmodulo.com/how-to-install-dummynet-on-centos.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果遇到问题，再返回这篇进一步学习&lt;/p&gt;
&lt;h1 id=&quot;dummynet简介&quot;&gt;&lt;a href=&quot;#dummynet简介&quot; class=&quot;headerlink&quot; title=&quot;dummynet简介&quot;&gt;&lt;/a&gt;dummynet简介&lt;/h1&gt;&lt;p&gt;dummynet 是linux下面(现在也可以部署在window下)一款开源的网络带宽控制工具，&lt;br&gt;在网站上线前，可能需要测试带宽对站点的影响。而dummynet就是为此而生。&lt;/p&gt;
&lt;h1 id=&quot;部署流程&quot;&gt;&lt;a href=&quot;#部署流程&quot; class=&quot;headerlink&quot; title=&quot;部署流程&quot;&gt;&lt;/a&gt;部署流程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;准备内核版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参看系统内核版本&lt;/p&gt;
&lt;p&gt;   &lt;code&gt;uname -r&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们需要将IPFW编译成内核模块，请确保&lt;br&gt;IPFW用到的内核源码版本同你LINUX系统运行内核版本一致。&lt;/p&gt;
&lt;p&gt;我的linux系统版本redhat7.2,内核版本3.10.0-327.13.1.el7.x86_64&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载此版本的内核源码包&lt;br&gt;kernel-3.10.0-327.13.1.el7.src.rpm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://vault.centos.org/7.2.1511/updates/Source/SPackages/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://vault.centos.org/7.2.1511/updates/Source/SPackages/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用wget或者直接下载放在/usr/src/kernels 目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;解压源码包&lt;/p&gt;
&lt;p&gt;`&lt;/p&gt;
&lt;p&gt;  rpm2cpio kernel-3.10.0-327.13.1.el7.src.rpm |cpio -div &lt;/p&gt;
&lt;p&gt;  tar xvf  linux-3.10.0-327.13.1.el7.tar.xz&lt;br&gt;  cd 3.10.0-327.13.1.el7.x86_64&lt;br&gt;  make oldconfig&lt;br&gt;  make prepare&lt;br&gt;  make scripts&lt;br&gt;`&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;编译dummynet&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/FS1360472174/dummynet.git
cd dummynet
make KERNELPATH=/usr/src/kernels/3.10.0-327.13.1.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;加载ipfw 模块&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd kipfw-mod
insmod ipfw_mod.ko
cd dummy/ipfw
cp ipfw /sbin
chmod 700 /sbin/ipfw
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;验证ipfw&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ipfw add pipe 1 icmp from xxx to xxx
ipfw pipe 1 config delay 100ms
ipfw pipe 1 config bw 128Kbytes/s 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除某个pipe&lt;br&gt;     ipfw delete #num&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;optional,将ipfw 设置为boot启动&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp ipfw_mod.ko /lib/modules/3.10.0-327.13.1.el7.x86_64/kernel/net/netfilter
depmod
sh -c &amp;apos;echo modprobe ipfw_mod &amp;gt;&amp;gt; /etc/rc.modules&amp;apos;
chmod +x /etc/rc.modules
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#问题分析 #&lt;br&gt;1.insmod: ERROR: could not insert module ipfw_mod.ko: Invalid module format&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;modinfo ipfw_mod.ko 看下vermagic版本是不是uname -r的版本。&lt;br&gt;然后重新编译ipfw 模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make KERNELPATH=/usr/src/kernels/3.10.0-327.13.1.el7.x86_64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.ipfw: getsockopt(IP_FW_ADD): Protocol not available&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;ipfw 模块未加载到内核&lt;br&gt;可以&lt;code&gt;lsmod |grep ipfw&lt;/code&gt;看下&lt;br&gt;需要重述上述步骤，将ipfw编译进内核模块&lt;/p&gt;
&lt;p&gt;3.编译模块时报错&lt;br&gt;类似于ipfw2_mod.c line 848 nf_hook_ops.hk struct have erors.&lt;/p&gt;
&lt;p&gt;解决：&lt;br&gt;Hook structure 在各个版本的linux中定义不一样，所以如果是从dummynet 站点中下载的&lt;br&gt;老的dummynet 包或者从这个download下来的包可能就有错误。&lt;br&gt;&lt;a href=&quot;https://github.com/luigirizzo/dummynet&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/luigirizzo/dummynet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建议你查看下当前所用系统的hook 结构&lt;/p&gt;
&lt;p&gt;/usr/src/kernels/linux-3.10.0-327.4.5.el7/include/linux/netfilter.h&lt;br&gt;定义了nf_hook_ops，nf_hookfn的结构&lt;br&gt;    struct nf_hook_ops {&lt;br&gt;        struct list_head list;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    /* User fills in from here down. */
    nf_hookfn       *hook;
    struct module   *owner;
    void            *priv;
    u_int8_t        pf;
    unsigned int    hooknum;
    /* Hooks are ordered in ascending priority. */
    int             priority;

    /* Reserved for use in the future RHEL versions. Set to zero. */
    unsigned long   __rht_reserved1;
    unsigned long   __rht_reserved2;
    unsigned long   __rht_reserved3;
    unsigned long   __rht_reserved4;
    unsigned long   __rht_reserved5;
};

typedef unsigned int nf_hookfn(const struct nf_hook_ops *ops,
   struct sk_buff *skb,
   const struct net_device *in,
   const struct net_device *out,
#ifndef __GENKSYMS__
   const struct nf_hook_state *state
#else
   int (*okfn)(struct sk_buff *)
#endif
   );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vault.centos.org/7.2.1511/updates/Source/SPackages/kernel-3.10.0-327.4.5.el7.src.rpm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://vault.centos.org/7.2.1511/updates/Source/SPackages/kernel-3.10.0-327.4.5.el7.src.rpm&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.rpmfind.net/linux/RPM/centos/updates/7.2.1511/x86_64/Packages/kernel-3.10.0-327.13.1.el7.x86_64.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.rpmfind.net/linux/RPM/centos/updates/7.2.1511/x86_64/Packages/kernel-3.10.0-327.13.1.el7.x86_64.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://xmodulo.com/how-to-install-dummynet-on-centos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xmodulo.com/how-to-install-dummynet-on-centos.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://access.redhat.com/articles/3078&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://access.redhat.com/articles/3078&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;在redhat 上部署dummynet 需要将ipfw 编译为内核模块，而ipfw需要调用linux kernel的一些函数。&lt;br&gt;linux kernel版本在不断提升，相关的数据结构也在变化。所以可能需要根据你要部署的系统内核版本，来调整参数&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git 常用命令</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/05/05/git/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/05/05/git/</id>
    <published>2016-05-05T08:10:41.853Z</published>
    <updated>2016-06-03T07:57:48.366Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;介绍常用的git命令&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;remote repo:&lt;/p&gt;
&lt;p&gt;personal repo:&lt;/p&gt;
&lt;p&gt;local repo:这个repo维护了文件修改历史，这样可以&lt;br&gt;进行回退&lt;/p&gt;
&lt;p&gt;disk content:&lt;/p&gt;
&lt;p&gt;1.apple patch&lt;/p&gt;
&lt;p&gt;git apply xxx.patch&lt;/p&gt;
&lt;p&gt;2.clone 指定的branch&lt;/p&gt;
&lt;p&gt;git clone -b &lt;branch&gt; &lt;remote_repo&gt;&lt;/remote_repo&gt;&lt;/branch&gt;&lt;/p&gt;
&lt;p&gt;3.查找本地branch&lt;/p&gt;
&lt;p&gt;git branch &lt;/p&gt;
&lt;p&gt;4.更换repo远程地址&lt;br&gt; git remote get-url origin //查看远程url&lt;br&gt; git remote set-url origin //设置新的url&lt;br&gt; git push // 提交到新的repo&lt;/p&gt;
&lt;p&gt;5.eclipse 中&lt;br&gt;git fetch,只是获取更新的head，并没有真正pull到本地&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;介绍常用的git命令&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cassandra develop in eclipse 环境构建</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/05/05/cassandra-buildin-eclipse/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/05/05/cassandra-buildin-eclipse/</id>
    <published>2016-05-05T08:07:24.235Z</published>
    <updated>2016-06-02T12:30:50.453Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文主要介绍如何在eclipse中搭建cassandra环境&lt;/p&gt;
&lt;p&gt;更多cassandra,nosql 相关知识请访问&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot;&gt;http://www.webpersonaldeveloper.cn&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;1.fork cassandra 代码&lt;br&gt;然后clone 到本地（cassandra-trunk 是head 分支)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/FS1360472174/cassandra.git
cassandra-trunk
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.&lt;code&gt;ant build&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这边有可能会出现字符编码问题，手动清除一下&lt;/p&gt;
&lt;p&gt;3.生成eclipse工程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ant generate-eclipse-files
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.生成jar包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ant
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;build 目录下会生成apache-cassandra-xxx.jar&lt;/p&gt;
&lt;p&gt;5.remote debug(java application 都可以通过配置jvm参数来进入远程debug)&lt;/p&gt;
&lt;p&gt;可以新建一个工程，将cassandra 的源码以包的形式导入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程server设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;远程cassandra 配置cassandra-env.sh 中配置JVM的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JVM_OPTS=&amp;quot;$JVM_OPTS -Xrunjdwp:transport=dt_socket,server=y,address=4004,suspend=n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;suspend =y 表示在客户端建立连接前，服务端被挂起；=n 则不会被挂起。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eclipse 设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在debug configuration中配置Remote Java Application.将host指定为cassandra node ip,port 指定上述添加&lt;br&gt;的address 4004 即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;E:\github\blog\source\_posts\images\remote.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;#参考&lt;br&gt;&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/incubator-cassandra-dev/200907.mbox/%3C123dcca0907041009o1b9e31cfh16139bc67ca11bbf@mail.gmail.com%3E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mail-archives.apache.org/mod_mbox/incubator-cassandra-dev/200907.mbox/%3C123dcca0907041009o1b9e31cfh16139bc67ca11bbf@mail.gmail.com%3E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.apache.org/cassandra/RunningCassandraInEclipse&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://wiki.apache.org/cassandra/RunningCassandraInEclipse&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文主要介绍如何在eclipse中搭建cassandra环境&lt;/p&gt;
&lt;p&gt;更多cassandra,nosql 相关知识请访问&lt;a href=&quot;http://www.webpersonaldeveloper.cn&quot;&gt;http://www.webpersonaldeveloper.cn&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cassandra java driver log 配置</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/04/29/cassandra-java-driver-log/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/04/29/cassandra-java-driver-log/</id>
    <published>2016-04-29T09:04:27.756Z</published>
    <updated>2016-06-02T12:32:07.217Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;介绍log配置&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;enable/disable trace log&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工程中不导入logback-classic.jar,logback-core.jar&lt;/p&gt;
&lt;p&gt;注意我们同样可以使用slf4j 来解决这个问题&lt;br&gt;&lt;a href=&quot;http://www.slf4j.org/codes.html#StaticLoggerBinder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.slf4j.org/codes.html#StaticLoggerBinder&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SLF4J: Failed to load class &amp;quot;org.slf4j.impl.StaticLoggerBinder&amp;quot;.
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是这样太过粗暴了，有时候我们需要java-driver的调试信息，比如像下面这样有用的信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DEBUG [cluster2] [/XXX:9042] Query completed normally, took 264 ms: [1 bound values] select * from TABLE where userid=? limit 5;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是默认的java-driver 级别是DEBUG,导致console中打印了太多的内容。&lt;/p&gt;
&lt;p&gt;造成了视觉污染，同时很难发现自己需要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置日志打印级别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方案1&lt;/p&gt;
&lt;p&gt;在每个insert/query 中设置disable/enable trace&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PreparedStatement ps = session.prepare(&amp;quot;&amp;quot;);
ps.setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM).disableTracing();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方案2&lt;/p&gt;
&lt;p&gt;方案1有效，但是试用场景有限，需要一个可配置的文件进行全局设置&lt;br&gt;以logback 为例。需要logback.xml 来配置，自定义DEBUG/INFO/WARN/WRONG级别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
&amp;lt;!-- log INFO or higher messages to the console --&amp;gt;
&amp;lt;appender name=&amp;quot;console&amp;quot; class=&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&amp;gt;
    &amp;lt;encoder&amp;gt;
        &amp;lt;pattern&amp;gt;%-5p %msg%n&amp;lt;/pattern&amp;gt;
    &amp;lt;/encoder&amp;gt;
&amp;lt;/appender&amp;gt;

&amp;lt;!-- log everything to a rolling file --&amp;gt;
&amp;lt;appender name=&amp;quot;file&amp;quot; class=&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&amp;gt;
    &amp;lt;file&amp;gt;driver.log&amp;lt;/file&amp;gt;
    &amp;lt;encoder&amp;gt;
        &amp;lt;pattern&amp;gt;%-5p [%d{ISO8601}] [%t] %F:%L - %msg%n&amp;lt;/pattern&amp;gt;
    &amp;lt;/encoder&amp;gt;
    &amp;lt;rollingPolicy class=&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&amp;gt;
        &amp;lt;!-- daily rollover --&amp;gt;
        &amp;lt;fileNamePattern&amp;gt;driver.%d{yyyy-MM-dd}.log&amp;lt;/fileNamePattern&amp;gt;
        &amp;lt;!-- keep 30 days&amp;apos; worth of history --&amp;gt;
        &amp;lt;maxHistory&amp;gt;30&amp;lt;/maxHistory&amp;gt;
&amp;lt;/rollingPolicy&amp;gt;
&amp;lt;/appender&amp;gt;

&amp;lt;!-- use AsyncAppender for lower latencies --&amp;gt;
&amp;lt;appender name=&amp;quot;async&amp;quot; class=&amp;quot;ch.qos.logback.classic.AsyncAppender&amp;quot;&amp;gt;
    &amp;lt;appender-ref ref=&amp;quot;console&amp;quot; /&amp;gt;
    &amp;lt;appender-ref ref=&amp;quot;file&amp;quot; /&amp;gt;
&amp;lt;/appender&amp;gt;

&amp;lt;!--
Turn on slow query logging by setting this logger to DEBUG; 
set level to TRACE to also log query parameters 
--&amp;gt;
&amp;lt;logger name=&amp;quot;com.datastax.driver.core.QueryLogger.SLOW&amp;quot; level=&amp;quot;DEBUG&amp;quot; /&amp;gt;

&amp;lt;root level=&amp;quot;ERROR&amp;quot;&amp;gt;
    &amp;lt;appender-ref ref=&amp;quot;async&amp;quot; /&amp;gt;
&amp;lt;/root&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://datastax.github.io/java-driver/2.1.7/features/logging/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://datastax.github.io/java-driver/2.1.7/features/logging/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;介绍log配置&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cassandra 写数据以及副本放置策略</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/04/28/cassandra-write/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/04/28/cassandra-write/</id>
    <published>2016-04-28T11:10:25.275Z</published>
    <updated>2016-06-02T12:33:38.333Z</updated>
    
    <content type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文主要介绍cassandra 在单节点以及跨数据中心如何写数据&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;application发送数据到server&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160417175535735&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;application 发送请求到server&lt;/li&gt;
&lt;li&gt;根据设置的load balance 规则从cluster中挑选一个coordinator，一般使用轮询即可。cluster 中的cassandra node 不仅作为数据库的储存节点，同样作为request 请求处理的server。所以保证每个节点处理的request 一样的balance算法即可&lt;/li&gt;
&lt;li&gt;然后根据插入数据的主键hash value,来将第一份数据写入到对应节点中&lt;/li&gt;
&lt;li&gt;然后根据replicator,write consistency,replication strategy ,来写副本&lt;br&gt;eg.replicator=3,write consistency=2,replication strategy=simple strategy&lt;br&gt;则表示成功写入到2个节点中，application的写操作才算成功。&lt;br&gt;simple strategy 表明副本是放在第一个node 节点环位置的下一个节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note-很重要的一点&lt;/strong&gt;&lt;br&gt;通过上面描述，发现可以根据hash value 来确定一条数据存放在哪个节点上，然后根据replication的参数设置，我们可以确定数据副本存放在哪个节点上。那么对于read 操作，我们就可以根据条件的hash value 来找到存放数据的第一个节点，然后根据数据副本来找其他replicate 数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面认识是错误的&lt;/strong&gt;&lt;br&gt;首先，考虑下如果我们添加node到cluster中，假如数据存放的第一个node hash 受到影响，数据要移除到新加入的node,这个操作很容易实现，那么按照我们上面的认识，其他的副本数据如何处理呢？&lt;br&gt;data的存放的第一个节点变化了，然后再根据replicate stragtegy,已经找不到其他副本了。&lt;br&gt;此外，cassandra 的node是无主机模式，没有主从节点，每份数据都是一样的，但是按照上面的说法，数据的存放的第一个节点重要性又高于其他节点。&lt;/p&gt;
&lt;p&gt;综上，上述认识错误&lt;br&gt;&lt;strong&gt;正确的认识&lt;/strong&gt;&lt;br&gt;cassandra 将数据成功写入后，会有一个map 表，来维护数据存放在哪些节点上&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nodetool getendpoint keyspace table partitionkey&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这条命令可以查询到数据存放在哪些node上面&lt;br&gt;看了下cassandra的源码，这些数据应该存放在org.apache.cassandra.db:type=StorageService中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写数据&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160417182913153&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写数据到commit log&lt;/li&gt;
&lt;li&gt;写数据到memtable&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt; 数据写入到这两个数据结构中，以及replicate 数目达到write consistency数目后，一次写操作就完成了，&lt;br&gt; 写数据是内存操作，所以cassandra 写入速度很快。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将数据从memtable中冲刷到sstable中&lt;br&gt;sstable中的数据是不可更改的&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文主要介绍cassandra 在单节点以及跨数据中心如何写数据&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.webpersonaldeveloper.cn/2016/04/27/hello-world/"/>
    <id>http://www.webpersonaldeveloper.cn/2016/04/27/hello-world/</id>
    <published>2016-04-27T14:01:42.830Z</published>
    <updated>2016-06-02T12:34:16.809Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
